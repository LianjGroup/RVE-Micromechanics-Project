
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Martensite Parent Grain Reconstruction</title><meta name="generator" content="MATLAB 9.14"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2023-05-21"><meta name="DC.source" content="script_MaParentGrainReconstruction.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Martensite Parent Grain Reconstruction</h1><!--introduction--><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#2">Setting up the parent grain reconstructor</a></li><li><a href="#5">Optimizing the parent child orientation relationship</a></li><li><a href="#8">Variant Graph based parent grain reconstruction</a></li><li><a href="#15">Merge similar grains and inclusions</a></li><li><a href="#17">Compute Child Variants</a></li><li><a href="#20">Parent EBSD reconstruction</a></li><li><a href="#22">Denoise the parent map</a></li></ul></div><p>This script demonstrates the tools MTEX offers to reconstruct a parent austenite phase from a measured martensite phase. The methods are described in more detail in the publications</p><div><ul><li><a href="https://arxiv.org/abs/2201.02103">The variant graph approach to improved parent grain reconstruction</a>, arXiv, 2022,</li><li><a href="https://doi.org/10.1107/S1600576721011560">Parent grain reconstruction from partially or fully transformed microstructures in MTEX</a>, J. Appl. Cryst. 55, 2022.</li></ul></div><p>We shall use the following sample data set.</p><pre class="codeinput"><span class="comment">% load the data</span>
mtexdata <span class="string">martensite</span>
plotx2east

<span class="comment">% grain reconstruction</span>
[grains,ebsd.grainId] = calcGrains(ebsd(<span class="string">'indexed'</span>), <span class="string">'angle'</span>, 3*degree);

<span class="comment">% remove small grains</span>
ebsd(grains(grains.grainSize &lt; 3)) = [];

<span class="comment">% reidentify grains with small grains removed:</span>
[grains,ebsd.grainId] = calcGrains(ebsd(<span class="string">'indexed'</span>),<span class="string">'angle'</span>,3*degree);
grains = smooth(grains,5);

<span class="comment">% plot the data and the grain boundaries</span>
plot(ebsd(<span class="string">'Iron bcc'</span>),ebsd(<span class="string">'Iron bcc'</span>).orientations,<span class="string">'figSize'</span>,<span class="string">'large'</span>)
hold <span class="string">on</span>
plot(grains.boundary,<span class="string">'linewidth'</span>,2)
hold <span class="string">off</span>
</pre><pre class="codeoutput"> 
ebsd = EBSD
 
 Phase  Orientations         Mineral         Color  Symmetry  Crystal reference frame
     0   92415 (27%)      notIndexed                                                 
     1  251187 (73%)  Iron bcc (old)  LightSkyBlue       432                         
 
 Properties: bands, bc, bs, error, mad, reliabilityindex, x, y
 Scan unit : um
 
</pre><img vspace="50" hspace="5" src="MaParentGrainReconstruction_01.png" alt=""> <h2 id="2">Setting up the parent grain reconstructor</h2><p>Grain reconstruction is guided in MTEX by a variable of type <a href="parentGrainReconstructor.parentGrainReconstructor.html"><tt>parentGrainReconstructor</tt></a>. During the reconstruction process this class keeps track about the relationship between the measured child grains and the recovered parent grains.</p><pre class="codeinput"><span class="comment">% set up the job</span>
job = parentGrainReconstructor(ebsd,grains);
</pre><p>The <tt>parentGrainReconstructor</tt> guesses from the EBSD data what is the parent and what is the child phase. If this guess is not correct it might be specified explicitely by defining an initial guess for the parent to child orientation relationship first and passing it as a third argument to <tt><a href="parentGrainReconstructor.parentGrainReconstructor.html">parentGrainReconstructor</a></tt>. Here we define this initial guess seperately as the Kurdjumov Sachs orientation relationship</p><pre class="codeinput"><span class="comment">% initial guess for the parent to child orientation relationship</span>
job.p2c = orientation.KurdjumovSachs(job.csParent, job.csChild)
<span class="comment">%job.p2c = orientation.NishiyamaWassermann(job.csParent, job.csChild)</span>
</pre><pre class="codeoutput"> 
job = parentGrainReconstructor
 
 phase   mineral         symmetry  grains  area  reconstructed
 parent  Iron fcc        432       0       0%    0%           
 child   Iron bcc (old)  432       7002    100%               
 
 OR: (111) || (011)   [10-1] || [11-1]
   c2c fit: 2.5&deg;, 3.4&deg;, 4.4&deg;, 5.4&deg; (quintiles)
 
</pre><p>The output of the variable <tt>job</tt> tells us the amount of parent and child grains as well as the percentage of already recovered parent grains. Furthermore, it displays how well the current guess of the parent to child orientation relationship fits the child to child misorientations within our data. In our sample data set this fit is described by the 4 quintiles 2.5&deg;, 3.5&deg;, 4.5&deg; and 5.5&deg;.</p><h2 id="5">Optimizing the parent child orientation relationship</h2><p>It is well known that the phase transformation from austenite to martensite is not described by a fixed orientation relationship. In fact, the actual orientation relationship needs to be determined for each sample individualy. Here, we used the iterative method proposed by Tuomo Nyyss&ouml;nen and implemented in the function <a href="calcParent2Child.html"><tt>calcParent2Child</tt></a> that starts at our initial guess of the orientation relation ship and iterates towards a more optimal orientation relationship.</p><pre class="codeinput">close <span class="string">all</span>
histogram(job.calcGBFit./degree,<span class="string">'BinMethod'</span>,<span class="string">'sqrt'</span>)
xlabel(<span class="string">'disorientation angle'</span>)

job.calcParent2Child
</pre><pre class="codeoutput"> 
ans = parentGrainReconstructor
 
 phase   mineral         symmetry  grains  area  reconstructed
 parent  Iron fcc        432       0       0%    0%           
 child   Iron bcc (old)  432       7002    100%               
 
 OR: (346.9&deg;,9.3&deg;,57.9&deg;)
   c2c fit: 1.4&deg;, 1.9&deg;, 2.3&deg;, 3.3&deg; (quintiles)
   closest ideal OR: (111) || (011)   [1-10] || [100] fit: 2.2&deg;
 
</pre><img vspace="50" hspace="5" src="MaParentGrainReconstruction_02.png" alt=""> <p>We observe that the optimized parent to child orientation relationship is 2.3&deg; off the initial Kurdjumov Sachs orientation relationship and reduced the first quintil of the misfit with the child to child misorientations to 1.5&deg;. These misfits are stored by the command <a href="calcParent2Child.html"><tt>calcParent2Child</tt></a> in the variable <tt>job.fit</tt>. In fact, the algorithm assumes that the majority of all boundary misorientations are child to child misorientations and finds the parent to child orientations relationship by minimizing this misfit. The following histogram displays the distribution of the misfit over all grain to grain misorientations.</p><pre class="codeinput">hold <span class="string">on</span>
histogram(job.calcGBFit./degree,<span class="string">'BinMethod'</span>,<span class="string">'sqrt'</span>)
hold <span class="string">off</span>
</pre><img vspace="50" hspace="5" src="MaParentGrainReconstruction_03.png" alt=""> <p>We may explicitely compute the misfit for all child to child boundaries using the command <a href="parentGrainReconstructor.calcGBFit.html"><tt>calcGBFit</tt></a>. Beside the list <tt>fit</tt> it returns also the list of grain pairs for which these fits have been computed. Using th command <a href="grainBoundary.selectByGrainId.html"><tt>selectByGrainId</tt></a> we can find the corresponding boundary segments and colorize them according to this misfit. In the code below we go one step further and adjust the transparency as a function of the misfit.</p><pre class="codeinput"><span class="comment">% compute the misfit for all child to child grain neighbours</span>
[fit,c2cPairs] = job.calcGBFit;

<span class="comment">% select grain boundary segments by grain ids</span>
[gB,pairId] = job.grains.boundary.selectByGrainId(c2cPairs);

<span class="comment">% plot the child phase</span>
plot(ebsd(<span class="string">'Iron bcc'</span>),ebsd(<span class="string">'Iron bcc'</span>).orientations,<span class="string">'figSize'</span>,<span class="string">'large'</span>,<span class="string">'faceAlpha'</span>,0.5)

<span class="comment">% and on top of it the boundaries colorized by the misfit</span>
hold <span class="string">on</span>;
<span class="comment">% scale fit between 0 and 1 - required for edgeAlpha</span>
plot(gB, <span class="string">'edgeAlpha'</span>, (fit(pairId) ./ degree - 2.5)./2 ,<span class="string">'linewidth'</span>,2);
hold <span class="string">off</span>
</pre><img vspace="50" hspace="5" src="MaParentGrainReconstruction_04.png" alt=""> <h2 id="8">Variant Graph based parent grain reconstruction</h2><p>Next we set up the variant graph where the nodes are the potential parent orientations of each child grain and the edges describe neighbouring grains that have compatible potential parent orientations. This graph is computed by the function <a href="parentGrainReconstructor.calcVariantGraph.html"><tt>calcVariantGraph</tt></a>. The edge weights are computed from the misfit between the potential parent orientations using a cumulative Gaussian distribution with the mean value <tt>'threshold'</tt> which describes the misfit at which the probability is exactly 50 percent and the standard deviation <tt>'tolerance'</tt>.</p><pre class="codeinput">job.calcVariantGraph(<span class="string">'threshold'</span>,2.5*degree,<span class="string">'tolerance'</span>,2.5*degree)
</pre><pre class="codeoutput"> 
ans = parentGrainReconstructor
 
 phase   mineral         symmetry  grains  area  reconstructed
 parent  Iron fcc        432       0       0%    0%           
 child   Iron bcc (old)  432       7002    100%               
 
 OR: (346.9&deg;,9.3&deg;,57.9&deg;)
   c2c fit: 1.4&deg;, 1.9&deg;, 2.2&deg;, 3.2&deg; (quintiles)
   closest ideal OR: (111) || (011)   [1-10] || [100] fit: 2.2&deg;
 
 variant graph: 213948 entries
 
</pre><p>For large maps it can be useful to perform the segmentation in a two step process, where in the in the first step similarly oriented variants are reconstructed as one variants and only seperated in a second step. This can be accomplished by the commands</p><pre class="language-matlab">job.calcVariantGraph(<span class="string">'threshold'</span>,2.5*degree,<span class="string">'tolerance'</span>,2.5*degree,<span class="string">'mergeSimilar'</span>)
job.clusterVariantGraph
job.calcVariantGraph(<span class="string">'threshold'</span>,2.5*degree,<span class="string">'tolerance'</span>,2.5*degree)
</pre><p>The next step is to cluster the variant graph into components. This is done by the command <a href="parentGrainReconstructor.clusterVariantGraph.html"><tt>clusterVariantGraph</tt></a>.</p><pre class="codeinput">job.clusterVariantGraph(<span class="string">'includeSimilar'</span>)
</pre><pre class="codeoutput"> 
ans = parentGrainReconstructor
 
 phase   mineral         symmetry  grains  area  reconstructed
 parent  Iron fcc        432       0       0%    0%           
 child   Iron bcc (old)  432       7002    100%               
 
 OR: (346.9&deg;,9.3&deg;,57.9&deg;)
   c2c fit: 1.4&deg;, 1.9&deg;, 2.2&deg;, 3.1&deg; (quintiles)
   closest ideal OR: (111) || (011)   [1-10] || [100] fit: 2.2&deg;
 
 votes: 7002 x 1
   probabilities: 100%, 100%, 99%, 97% (quintiles)
 
</pre><p>As a result a table of votes <tt>job.votes</tt> is generated. More specificaly, <tt>job.votes.prob</tt> is a matrix that contains in row <tt>job.votes.prob(i,:)</tt> the probabilities of the i-th child grain to have a specific parent orientation. Accordingly, we can plot the probability of the best fit for each grain by</p><pre class="codeinput">plot(job.grains,job.votes.prob(:,1))
mtexColorbar
</pre><img vspace="50" hspace="5" src="MaParentGrainReconstruction_05.png" alt=""> <p>We observe many child grains where the algorithm is sure about the parent orientation and some child grains where the probability is close to 50 percent. This is an indication that there are a least two potential parent orientations which are similarly likely. In many cases these potential parent orientations are in a twinning relationship.</p><p>Lets reconstruct all parent orientations where the probability is above 50 percent.</p><pre class="codeinput">job.calcParentFromVote(<span class="string">'minProb'</span>,0.5)

<span class="comment">% plot the result</span>
plot(job.parentGrains,job.parentGrains.meanOrientation)
</pre><pre class="codeoutput"> 
ans = parentGrainReconstructor
 
 phase   mineral         symmetry  grains  area   reconstructed
 parent  Iron fcc        432       6886    99%    98%          
 child   Iron bcc (old)  432       116     0.58%               
 
 OR: (346.9&deg;,9.3&deg;,57.9&deg;)
   p2c fit: 3.4&deg;, 5.2&deg;, 10&deg;, 20&deg; (quintiles)
   c2c fit: 1.8&deg;, 2.6&deg;, 3.4&deg;, 3.7&deg; (quintiles)
   closest ideal OR: (111) || (011)   [1-10] || [100] fit: 2.2&deg;
 
 votes: 116 x 1
   probabilities: 0.37%, 0%, 0%, 0% (quintiles)
 
</pre><img vspace="50" hspace="5" src="MaParentGrainReconstruction_06.png" alt=""> <p>From here we have different possibilities to continue. One possibility is to reconstruct the remaining parent orientations manually. To this end one can use the the command <a href="parentGrainReconstructor.selectInteractive.html"><tt>job.selectInteractive</tt></a>. This allow to click any grain and to change its parent orientation into one of the potential parent orientations.</p><pre class="codeinput">job.selectInteractive
</pre><p>A second way would be to rerun the variant graph approach above a second time but with relaxed settings, i.e., with a lower probability. A third way is to use the command <a href="parentGrainReconstructor.calcGBVotes.html"><tt>job.calcGBVotes</tt></a> to compute votes for potential parent orientations from the surrounding already reconstructed parent grains.</p><pre class="codeinput"><span class="comment">% compute the votes</span>
job.calcGBVotes(<span class="string">'p2c'</span>,<span class="string">'reconsiderAll'</span>)

<span class="comment">% assign parent orientations according to the votes</span>
job.calcParentFromVote

<span class="comment">% plot the result</span>
plot(job.parentGrains,job.parentGrains.meanOrientation)
</pre><pre class="codeoutput"> 
ans = parentGrainReconstructor
 
 phase   mineral         symmetry  grains  area   reconstructed
 parent  Iron fcc        432       6886    99%    98%          
 child   Iron bcc (old)  432       116     0.58%               
 
 OR: (346.9&deg;,9.3&deg;,57.9&deg;)
   p2c fit: 3.4&deg;, 5.2&deg;, 10&deg;, 20&deg; (quintiles)
   c2c fit: 1.8&deg;, 2.6&deg;, 3.4&deg;, 3.7&deg; (quintiles)
   closest ideal OR: (111) || (011)   [1-10] || [100] fit: 2.2&deg;
 
 votes: 6748 x 1
   probabilities: 88%, 75%, 58%, 37% (quintiles)
 
 
ans = parentGrainReconstructor
 
 phase   mineral         symmetry  grains  area   reconstructed
 parent  Iron fcc        432       6907    100%   99%          
 child   Iron bcc (old)  432       95      0.25%               
 
 OR: (346.9&deg;,9.3&deg;,57.9&deg;)
   p2c fit: 4.7&deg;, 6.8&deg;, 13&deg;, 21&deg; (quintiles)
   c2c fit: 1.8&deg;, 2.6&deg;, 3.6&deg;, 5.8&deg; (quintiles)
   closest ideal OR: (111) || (011)   [1-10] || [100] fit: 2.2&deg;
 
</pre><img vspace="50" hspace="5" src="MaParentGrainReconstruction_07.png" alt=""> <h2 id="15">Merge similar grains and inclusions</h2><p>After the above reconstruction steps most of the child grains have been reverted into parent grains. However, instead of a few big parent grains we still have many small, but similarly oriented parent grains. These can be merged into big parent grains using the command <a href="parentGrainReconstructor.mergeSimilar.html"><tt>mergeSimilar</tt></a></p><pre class="codeinput"><span class="comment">% merge grains with similar orientation</span>
job.mergeSimilar(<span class="string">'threshold'</span>,7.5*degree);

<span class="comment">% plot the result</span>
plot(job.parentGrains,job.parentGrains.meanOrientation)
</pre><img vspace="50" hspace="5" src="MaParentGrainReconstruction_08.png" alt=""> <p>We may be still a bit unsatisfied with the result as the large parent grains contain many poorly indexed inclusions where we failed to assign to a parent orientation. We may use the command <a href="parentGrainReconstructor.mergeInclusions.html"><tt>mergeInclusions</tt></a> to merge all inclusions with fever pixels then a certain threshold into the surrounding parent grains.</p><pre class="codeinput">job.mergeInclusions(<span class="string">'maxSize'</span>,50);

<span class="comment">% plot the result</span>
plot(job.parentGrains,job.parentGrains.meanOrientation)
</pre><img vspace="50" hspace="5" src="MaParentGrainReconstruction_09.png" alt=""> <h2 id="17">Compute Child Variants</h2><p>Knowing the parent grain orientations we may compute the variants and packets of each child grain using the command <a href="parentGrainReconstructor.calcVariants.html"><tt>calcVariants</tt></a>. The values are stored with the properties <tt>job.transformedGrains.variantId</tt> and <tt>job.transformedGrains.packetId</tt>. The <tt>packetId</tt> is defined as the closest {111} plane in austenite to the (011) plane in martensite.</p><pre class="codeinput">job.calcVariants

<span class="comment">% associate to each packet id a color and plot</span>
color = ind2color(job.transformedGrains.packetId);
plot(job.transformedGrains,color,<span class="string">'faceAlpha'</span>,0.5)

hold <span class="string">on</span>
parentGrains = smooth(job.parentGrains,10);
plot(parentGrains.boundary,<span class="string">'linewidth'</span>,3)

<span class="comment">% outline a specific parent grain</span>
grainSelected = parentGrains(parentGrains.findByLocation([100,80]));

hold <span class="string">on</span>
plot(grainSelected.boundary,<span class="string">'linewidth'</span>,3,<span class="string">'lineColor'</span>,<span class="string">'w'</span>)
hold <span class="string">off</span>
</pre><img vspace="50" hspace="5" src="MaParentGrainReconstruction_10.png" alt=""> <p>We can also directly identify the child grains belonging to the selected parent grains. Remeber that the initial grains are stored in <tt>job.grainsPrior</tt> and that the vector <tt>job.mergeId</tt> stores for every initial grain the <tt>id</tt> of the corresponding parent grain. Combining these two information we do</p><pre class="codeinput"><span class="comment">% identify childs of the selected parent grain</span>
childGrains = job.grainsPrior(job.mergeId == grainSelected.id);

<span class="comment">% plot these childs</span>
plot(childGrains,childGrains.meanOrientation)

<span class="comment">% and top the parent grain boundary</span>
hold <span class="string">on</span>
plot(grainSelected.boundary,<span class="string">'linewidth'</span>,2)
hold <span class="string">off</span>
</pre><img vspace="50" hspace="5" src="MaParentGrainReconstruction_11.png" alt=""> <p>In order to check our parent grain reconstruction we chose the single parent grain outlined in the above map and plot all child variants of its reconstructed parent orientation together with the actually measured child orientations inside the parent grain. In order to compute the <tt>variantId</tt> and <tt>packetId</tt> we use the command <a href="calcVariantId.html"><tt>calcVariantId</tt></a>.</p><pre class="codeinput"><span class="comment">% the measured child orientations that belong to parent grain 279</span>
childOri = job.ebsdPrior(childGrains).orientations;

<span class="comment">% the orientation of parent grain 279</span>
parentOri = grainSelected.meanOrientation;

<span class="comment">% lets compute the variant and packeIds</span>
[variantId, packetId] = calcVariantId(parentOri,childOri,job.p2c);

<span class="comment">% colorize child orientations by packetId</span>
color = ind2color(packetId);
plotPDF(childOri,color, Miller(0,0,1,childOri.CS),<span class="string">'MarkerSize'</span>,2,<span class="string">'all'</span>)

<span class="comment">% the positions of the parent (001) directions</span>
hold <span class="string">on</span>
plot(parentOri.symmetrise * Miller(0,0,1,parentOri.CS),<span class="string">'markerSize'</span>,10,<span class="keyword">...</span>
  <span class="string">'marker'</span>,<span class="string">'s'</span>,<span class="string">'markerFaceColor'</span>,<span class="string">'w'</span>,<span class="string">'MarkerEdgeColor'</span>,<span class="string">'k'</span>,<span class="string">'linewidth'</span>,2)

<span class="comment">% the theoretical child variants</span>
childVariants = variants(job.p2c, parentOri);
plotPDF(childVariants, <span class="string">'markerFaceColor'</span>,<span class="string">'none'</span>,<span class="string">'linewidth'</span>,1.5,<span class="string">'markerEdgeColor'</span>,<span class="string">'k'</span>)
hold <span class="string">off</span>
</pre><img vspace="50" hspace="5" src="MaParentGrainReconstruction_12.png" alt=""> <h2 id="20">Parent EBSD reconstruction</h2><p>So far our analysis was at the grain level. However, once parent grain orientations have been computed we may also use them to compute parent orientations of each pixel in our original EBSD map. This is done by the command <a href="parentGrainReconstructor.calcParentEBSD.html"><tt>calcParentEBSD</tt></a></p><pre class="codeinput">parentEBSD = job.calcParentEBSD;

<span class="comment">% plot the result</span>
plot(parentEBSD(<span class="string">'Iron fcc'</span>),parentEBSD(<span class="string">'Iron fcc'</span>).orientations,<span class="string">'figSize'</span>,<span class="string">'large'</span>)
</pre><img vspace="50" hspace="5" src="MaParentGrainReconstruction_13.png" alt=""> <p>We obtain even a measure <tt>parentEBSD.fit</tt> for the corespondence between the parent orientation reconstructed from the single pixel and the parent orientation of the grain. Lets visualize this fit</p><pre class="codeinput"><span class="comment">% the fit between ebsd child orientation and the reconstructed parent grain</span>
<span class="comment">% orientation</span>
plot(parentEBSD, parentEBSD.fit ./ degree,<span class="string">'figSize'</span>,<span class="string">'large'</span>)
mtexColorbar
setColorRange([0,5])
mtexColorMap(<span class="string">'LaboTeX'</span>)

hold <span class="string">on</span>
plot(job.grains.boundary,<span class="string">'lineWidth'</span>,2)
hold <span class="string">off</span>
</pre><img vspace="50" hspace="5" src="MaParentGrainReconstruction_14.png" alt=""> <h2 id="22">Denoise the parent map</h2><p>Finaly we may apply filtering to the parent map to fill non indexed or not reconstructed pixels. To this end we first run grain reconstruction on the parent map</p><pre class="codeinput">[parentGrains, parentEBSD.grainId] = calcGrains(parentEBSD(<span class="string">'indexed'</span>),<span class="string">'angle'</span>,3*degree);

<span class="comment">% remove very small grains</span>
parentEBSD(parentGrains(parentGrains.grainSize&lt;10)) = [];

<span class="comment">% redo grain reconstrucion</span>
[parentGrains, parentEBSD.grainId] = calcGrains(parentEBSD(<span class="string">'indexed'</span>),<span class="string">'angle'</span>,3*degree);
parentGrains = smooth(parentGrains,10);

plot(ebsd(<span class="string">'indexed'</span>),ebsd(<span class="string">'indexed'</span>).orientations,<span class="string">'figSize'</span>,<span class="string">'large'</span>)

hold <span class="string">on</span>
plot(parentGrains.boundary,<span class="string">'lineWidth'</span>,2)
hold <span class="string">off</span>
</pre><img vspace="50" hspace="5" src="MaParentGrainReconstruction_15.png" alt=""> <p>and then use the command <a href="EBSD.smooth.html"><tt>smooth</tt></a> to fill the holes in the reconstructed parent map</p><pre class="codeinput"><span class="comment">% fill the holes</span>
F = halfQuadraticFilter;
parentEBSD = smooth(parentEBSD(<span class="string">'indexed'</span>),F,<span class="string">'fill'</span>,parentGrains);

<span class="comment">% plot the parent map</span>
plot(parentEBSD(<span class="string">'Iron fcc'</span>),parentEBSD(<span class="string">'Iron fcc'</span>).orientations,<span class="string">'figSize'</span>,<span class="string">'large'</span>)

<span class="comment">% with grain boundaries</span>
hold <span class="string">on</span>
plot(parentGrains.boundary,<span class="string">'lineWidth'</span>,2)
hold <span class="string">off</span>
</pre><img vspace="50" hspace="5" src="MaParentGrainReconstruction_16.png" alt=""> <p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2023a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Martensite Parent Grain Reconstruction
%
%% 
% This script demonstrates the tools MTEX offers to reconstruct a parent
% austenite phase from a measured martensite phase. The methods are
% described in more detail in the publications 
%
% * <https://arxiv.org/abs/2201.02103 The variant graph approach to
% improved parent grain reconstruction>, arXiv, 2022,
% * <https://doi.org/10.1107/S1600576721011560 Parent grain reconstruction from partially or fully transformed
% microstructures in MTEX>, J. Appl. Cryst. 55, 2022.
% 
% We shall use the following sample data set.

% load the data
mtexdata martensite 
plotx2east

% grain reconstruction
[grains,ebsd.grainId] = calcGrains(ebsd('indexed'), 'angle', 3*degree);

% remove small grains
ebsd(grains(grains.grainSize < 3)) = [];

% reidentify grains with small grains removed:
[grains,ebsd.grainId] = calcGrains(ebsd('indexed'),'angle',3*degree);
grains = smooth(grains,5);

% plot the data and the grain boundaries
plot(ebsd('Iron bcc'),ebsd('Iron bcc').orientations,'figSize','large')
hold on
plot(grains.boundary,'linewidth',2)
hold off

%% Setting up the parent grain reconstructor
% 
% Grain reconstruction is guided in MTEX by a variable of type
% <parentGrainReconstructor.parentGrainReconstructor.html
% |parentGrainReconstructor|>. During the reconstruction process this class
% keeps track about the relationship between the measured child grains and
% the recovered parent grains.

% set up the job
job = parentGrainReconstructor(ebsd,grains);

%%
% The |parentGrainReconstructor| guesses from the EBSD data what is the
% parent and what is the child phase. If this guess is not correct it might
% be specified explicitely by defining an initial guess for the parent to
% child orientation relationship first and passing it as a third argument to
% |<parentGrainReconstructor.parentGrainReconstructor.html
% parentGrainReconstructor>|. Here we define this initial guess seperately
% as the Kurdjumov Sachs orientation relationship

% initial guess for the parent to child orientation relationship
job.p2c = orientation.KurdjumovSachs(job.csParent, job.csChild)
%job.p2c = orientation.NishiyamaWassermann(job.csParent, job.csChild)

%%
% The output of the variable |job| tells us the amount of parent and child
% grains as well as the percentage of already recovered parent grains.
% Furthermore, it displays how well the current guess of the parent to
% child orientation relationship fits the child to child misorientations
% within our data. In our sample data set this fit is described by the 4
% quintiles 2.5°, 3.5°, 4.5° and 5.5°.
%
%% Optimizing the parent child orientation relationship
%
% It is well known that the phase transformation from austenite to
% martensite is not described by a fixed orientation relationship. In fact,
% the actual orientation relationship needs to be determined for each
% sample individualy. Here, we used the iterative method proposed by Tuomo
% Nyyssönen and implemented in the function <calcParent2Child.html
% |calcParent2Child|> that starts at our initial guess of the orientation
% relation ship and iterates towards a more optimal orientation
% relationship.

close all
histogram(job.calcGBFit./degree,'BinMethod','sqrt')
xlabel('disorientation angle')

job.calcParent2Child

%%
% We observe that the optimized parent to child orientation relationship is
% 2.3° off the initial Kurdjumov Sachs orientation relationship
% and reduced the first quintil of the misfit with the child to child
% misorientations to 1.5°. These misfits are stored by the
% command <calcParent2Child.html |calcParent2Child|> in the variable
% |job.fit|. In fact, the algorithm assumes that the majority of all
% boundary misorientations are child to child misorientations and finds the
% parent to child orientations relationship by minimizing this misfit. The
% following histogram displays the distribution of the misfit over all
% grain to grain misorientations.

hold on
histogram(job.calcGBFit./degree,'BinMethod','sqrt')
hold off

%%
% We may explicitely compute the misfit for all child to child
% boundaries using the command <parentGrainReconstructor.calcGBFit.html
% |calcGBFit|>. Beside the list |fit| it returns also the list of grain
% pairs for which these fits have been computed. Using th command
% <grainBoundary.selectByGrainId.html |selectByGrainId|> we can find the
% corresponding boundary segments and colorize them according to this
% misfit. In the code below we go one step further and adjust the
% transparency as a function of the misfit.

% compute the misfit for all child to child grain neighbours
[fit,c2cPairs] = job.calcGBFit;

% select grain boundary segments by grain ids
[gB,pairId] = job.grains.boundary.selectByGrainId(c2cPairs);

% plot the child phase
plot(ebsd('Iron bcc'),ebsd('Iron bcc').orientations,'figSize','large','faceAlpha',0.5)

% and on top of it the boundaries colorized by the misfit
hold on;
% scale fit between 0 and 1 - required for edgeAlpha
plot(gB, 'edgeAlpha', (fit(pairId) ./ degree - 2.5)./2 ,'linewidth',2);
hold off

%% Variant Graph based parent grain reconstruction
%
% Next we set up the variant graph where the nodes are the potential parent
% orientations of each child grain and the edges describe neighbouring
% grains that have compatible potential parent orientations. This graph is
% computed by the function <parentGrainReconstructor.calcVariantGraph.html
% |calcVariantGraph|>. The edge weights are computed from the misfit
% between the potential parent orientations using a cumulative Gaussian
% distribution with the mean value |'threshold'| which describes the misfit
% at which the probability is exactly 50 percent and the standard deviation
% |'tolerance'|.

job.calcVariantGraph('threshold',2.5*degree,'tolerance',2.5*degree)

%%
% For large maps it can be useful to perform the segmentation in a two step
% process, where in the in the first step similarly oriented variants are
% reconstructed as one variants and only seperated in a second step. This
% can be accomplished by the commands
% 
%   job.calcVariantGraph('threshold',2.5*degree,'tolerance',2.5*degree,'mergeSimilar')
%   job.clusterVariantGraph 
%   job.calcVariantGraph('threshold',2.5*degree,'tolerance',2.5*degree)
%
%%
% The next step is to cluster the variant graph into components. This is
% done by the command <parentGrainReconstructor.clusterVariantGraph.html
% |clusterVariantGraph|>.

job.clusterVariantGraph('includeSimilar')

%%
% As a result a table of votes |job.votes| is generated. More specificaly,
% |job.votes.prob| is a matrix that contains in row |job.votes.prob(i,:)|
% the probabilities of the i-th child grain to have a specific parent
% orientation. Accordingly, we can plot the probability of the best fit for
% each grain by

plot(job.grains,job.votes.prob(:,1))
mtexColorbar

%%
% We observe many child grains where the algorithm is sure about the parent
% orientation and some child grains where the probability is close to 50
% percent. This is an indication that there are a least two potential
% parent orientations which are similarly likely. In many cases these
% potential parent orientations are in a twinning relationship.
%
% Lets reconstruct all parent orientations where the probability is above
% 50 percent.

job.calcParentFromVote('minProb',0.5)

% plot the result
plot(job.parentGrains,job.parentGrains.meanOrientation)

%%
% From here we have different possibilities to continue. One possibility is
% to reconstruct the remaining parent orientations manually. To this end
% one can use the the command
% <parentGrainReconstructor.selectInteractive.html
% |job.selectInteractive|>. This allow to click any grain and to change its
% parent orientation into one of the potential parent orientations.

job.selectInteractive

%%
% A second way would be to rerun the variant graph approach above a second
% time but with relaxed settings, i.e., with a lower probability. A third
% way is to use the command <parentGrainReconstructor.calcGBVotes.html
% |job.calcGBVotes|> to compute votes for potential parent orientations
% from the surrounding already reconstructed parent grains. 

% compute the votes
job.calcGBVotes('p2c','reconsiderAll')

% assign parent orientations according to the votes
job.calcParentFromVote

% plot the result
plot(job.parentGrains,job.parentGrains.meanOrientation)

%% Merge similar grains and inclusions
%
% After the above reconstruction steps most of the child grains have been
% reverted into parent grains. However, instead of a few big parent grains
% we still have many small, but similarly oriented parent grains. These can
% be merged into big parent grains using the command
% <parentGrainReconstructor.mergeSimilar.html |mergeSimilar|>

% merge grains with similar orientation
job.mergeSimilar('threshold',7.5*degree);

% plot the result
plot(job.parentGrains,job.parentGrains.meanOrientation)

%%
% We may be still a bit unsatisfied with the result as the large parent
% grains contain many poorly indexed inclusions where we failed to assign
% to a parent orientation. We may use the command
% <parentGrainReconstructor.mergeInclusions.html |mergeInclusions|> to
% merge all inclusions with fever pixels then a certain threshold into the
% surrounding parent grains.

job.mergeInclusions('maxSize',50);

% plot the result
plot(job.parentGrains,job.parentGrains.meanOrientation)

%% Compute Child Variants
% 
% Knowing the parent grain orientations we may compute the variants and
% packets of each child grain using the command
% <parentGrainReconstructor.calcVariants.html |calcVariants|>. The values
% are stored with the properties |job.transformedGrains.variantId| and
% |job.transformedGrains.packetId|. The |packetId| is defined as the
% closest {111} plane in austenite to the (011) plane in martensite.

job.calcVariants

% associate to each packet id a color and plot
color = ind2color(job.transformedGrains.packetId);
plot(job.transformedGrains,color,'faceAlpha',0.5)

hold on
parentGrains = smooth(job.parentGrains,10);
plot(parentGrains.boundary,'linewidth',3)

% outline a specific parent grain
grainSelected = parentGrains(parentGrains.findByLocation([100,80]));

hold on
plot(grainSelected.boundary,'linewidth',3,'lineColor','w')
hold off

%%
% We can also directly identify the child grains belonging to the selected
% parent grains. Remeber that the initial grains are stored in
% |job.grainsPrior| and that the vector |job.mergeId| stores for every
% initial grain the |id| of the corresponding parent grain. Combining these
% two information we do

% identify childs of the selected parent grain
childGrains = job.grainsPrior(job.mergeId == grainSelected.id);

% plot these childs 
plot(childGrains,childGrains.meanOrientation)

% and top the parent grain boundary 
hold on
plot(grainSelected.boundary,'linewidth',2)
hold off

%% 
% In order to check our parent grain reconstruction we chose the single
% parent grain outlined in the above map and plot all child variants of its
% reconstructed parent orientation together with the actually measured
% child orientations inside the parent grain. In order to compute the
% |variantId| and |packetId| we use the command <calcVariantId.html
% |calcVariantId|>.

% the measured child orientations that belong to parent grain 279
childOri = job.ebsdPrior(childGrains).orientations;

% the orientation of parent grain 279
parentOri = grainSelected.meanOrientation;

% lets compute the variant and packeIds
[variantId, packetId] = calcVariantId(parentOri,childOri,job.p2c);

% colorize child orientations by packetId
color = ind2color(packetId);
plotPDF(childOri,color, Miller(0,0,1,childOri.CS),'MarkerSize',2,'all')

% the positions of the parent (001) directions
hold on
plot(parentOri.symmetrise * Miller(0,0,1,parentOri.CS),'markerSize',10,...
  'marker','s','markerFaceColor','w','MarkerEdgeColor','k','linewidth',2)

% the theoretical child variants
childVariants = variants(job.p2c, parentOri);
plotPDF(childVariants, 'markerFaceColor','none','linewidth',1.5,'markerEdgeColor','k')
hold off

%% Parent EBSD reconstruction
%
% So far our analysis was at the grain level. However, once parent grain
% orientations have been computed we may also use them to compute parent
% orientations of each pixel in our original EBSD map. This is done by the
% command <parentGrainReconstructor.calcParentEBSD.html |calcParentEBSD|>

parentEBSD = job.calcParentEBSD;

% plot the result
plot(parentEBSD('Iron fcc'),parentEBSD('Iron fcc').orientations,'figSize','large')

%%
% We obtain even a measure |parentEBSD.fit| for the corespondence between
% the parent orientation reconstructed from the single pixel and the parent
% orientation of the grain. Lets visualize this fit

% the fit between ebsd child orientation and the reconstructed parent grain
% orientation
plot(parentEBSD, parentEBSD.fit ./ degree,'figSize','large')
mtexColorbar
setColorRange([0,5])
mtexColorMap('LaboTeX')

hold on
plot(job.grains.boundary,'lineWidth',2)
hold off


%% Denoise the parent map
%
% Finaly we may apply filtering to the parent map to fill non indexed or
% not reconstructed pixels. To this end we first run grain reconstruction
% on the parent map

[parentGrains, parentEBSD.grainId] = calcGrains(parentEBSD('indexed'),'angle',3*degree);

% remove very small grains
parentEBSD(parentGrains(parentGrains.grainSize<10)) = [];

% redo grain reconstrucion
[parentGrains, parentEBSD.grainId] = calcGrains(parentEBSD('indexed'),'angle',3*degree);
parentGrains = smooth(parentGrains,10);

plot(ebsd('indexed'),ebsd('indexed').orientations,'figSize','large')

hold on
plot(parentGrains.boundary,'lineWidth',2)
hold off

%%
% and then use the command <EBSD.smooth.html |smooth|> to fill the holes in
% the reconstructed parent map

% fill the holes
F = halfQuadraticFilter;
parentEBSD = smooth(parentEBSD('indexed'),F,'fill',parentGrains);

% plot the parent map
plot(parentEBSD('Iron fcc'),parentEBSD('Iron fcc').orientations,'figSize','large')

% with grain boundaries
hold on
plot(parentGrains.boundary,'lineWidth',2)
hold off

##### SOURCE END #####
--></body></html>