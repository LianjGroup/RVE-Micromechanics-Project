
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Crystal Shapes</title><meta name="generator" content="MATLAB 9.14"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2023-05-21"><meta name="DC.source" content="script_CrystalShapes.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Crystal Shapes</h1><!--introduction--><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#2">Simple crystal shapes</a></li><li><a href="#4">Calculating with crystal shapes</a></li><li><a href="#6">Plotting crystal shapes</a></li><li><a href="#9">Twinning relationships</a></li><li><a href="#10">Defining complicated crystal shapes</a></li><li><a href="#17">Marking crystal faces</a></li><li><a href="#19">Defining complicated crystals more simple</a></li><li><a href="#22">Select faces</a></li><li><a href="#23">Gallery of hardcoded crystal shapes</a></li></ul></div><p>Crystal Shapes are used to visualize crystal orientations, twinning or lattice planes.</p><h2 id="2">Simple crystal shapes</h2><p>In the case of cubic or hexagonal materials the corresponding crystal are often represented as cubes or hexagons, where the faces correspond to the lattice planes {100} in the cubic case and {1,0,-1,0},{0,0,0,1} in the hexagonal case. Such simple crystal shapes may be created in MTEX with the commands</p><pre class="codeinput"><span class="comment">% import some hexagonal data</span>
mtexdata <span class="string">titanium</span>;

<span class="comment">% define a simple hexagonal crystal shape</span>
cS = crystalShape.hex(ebsd.CS)

<span class="comment">% and plot it</span>
close <span class="string">all</span>
plot(cS)
</pre><pre class="codeoutput"> 
ebsd = EBSD
 
 Phase  Orientations           Mineral         Color  Symmetry  Crystal reference frame
     0   8100 (100%)  Titanium (Alpha)  LightSkyBlue       622       X||a, Y||b*, Z||c*
 
 Properties: ci, grainid, iq, sem_signal, x, y
 Scan unit : um
 
 
cS = crystalShape
 mineral: Titanium (Alpha) (622, X||a, Y||b*, Z||c*)
 vertices: 12
 faces: 8
</pre><img vspace="50" hspace="5" src="CrystalShapes_01.png" alt=""> <p>Internally, a crystal shape is represented as a list of faces which are bounded by a list of vertices</p><pre class="codeinput">cS.V
</pre><pre class="codeoutput"> 
ans = vector3d
 size: 12 x 1
</pre><h2 id="4">Calculating with crystal shapes</h2><p>Crystal shapes are defined in crystal coordinates. Thus applying an orientation rotates them into specimen coordinates. This functionality can be used to visualize crystal orientations in EBSD maps</p><pre class="codeinput"><span class="comment">% plot an EBSD map</span>
clf <span class="comment">% clear current figure</span>
plot(ebsd,ebsd.orientations)

hold <span class="string">on</span>
scaling = 100; <span class="comment">% scale the crystal shape to have a nice size</span>

<span class="comment">% plot at position (500,500) the orientatation of the corresponding crystal</span>
plot(500,500,50, ebsd(500,500).orientations * cS * scaling)
hold <span class="string">off</span>
</pre><img vspace="50" hspace="5" src="CrystalShapes_02.png" alt=""> <p>As we have seen in the previous section we can apply several operations on crystal shapes. These include</p><div><ul><li><tt>factor * cS</tt> scales the crystal shape in size</li><li><tt>ori * cS</tt> rotates the crystal shape in the defined orientation</li><li><tt>[xy] + cS</tt> or <tt>[xyz] + cS</tt> shifts the crystal shape in the specified positions</li></ul></div><p>At this point it comes into help that MTEX supports lists of crystal shapes, i.e., whenever one of the operations listed above includes a list (e.g. a list of orientations) the multiplication will yield a list of crystal shapes. Lets illustrate this</p><pre class="codeinput"><span class="comment">% compute some grains</span>
grains = calcGrains(ebsd);
grains = smooth(grains,5);

<span class="comment">% and plot them</span>
plot(grains,grains.meanOrientation)

<span class="comment">% find the big ones</span>
isBig = grains.grainSize&gt;50;

<span class="comment">% define a list of crystal shape that is oriented as the grain mean</span>
<span class="comment">% orientation and scaled according to the grain area</span>
cSGrains = grains(isBig).meanOrientation * cS * 0.7 * sqrt(grains(isBig).area);

<span class="comment">% now we can plot these crystal shapes at the grain centers</span>
hold <span class="string">on</span>
plot(grains(isBig).centroid + cSGrains)
hold <span class="string">off</span>
</pre><img vspace="50" hspace="5" src="CrystalShapes_03.png" alt=""> <h2 id="6">Plotting crystal shapes</h2><p>The above can be accomplished a bit more directly and a bit more nice with</p><pre class="codeinput"><span class="comment">% plot a grain map</span>
plot(grains,grains.meanOrientation)

<span class="comment">% and on top for each large grain a crystal shape</span>
hold <span class="string">on</span>
plot(grains(isBig),0.7*cS,<span class="string">'FaceColor'</span>,<span class="string">'none'</span>,<span class="string">'linewidth'</span>,2)
hold <span class="string">off</span>
</pre><img vspace="50" hspace="5" src="CrystalShapes_04.png" alt=""> <p>In the same waywe may visualize grain orientations and grains size within pole figures</p><pre class="codeinput">plotPDF(grains(isBig).meanOrientation,Miller({1,0,-1,0},{0,0,0,1},ebsd.CS),<span class="string">'contour'</span>)
plot(grains(isBig).meanOrientation,0.002*cSGrains,<span class="string">'add2all'</span>)
</pre><img vspace="50" hspace="5" src="CrystalShapes_05.png" alt=""> <p>or even within ODF sections</p><pre class="codeinput"><span class="comment">% compute the odf</span>
odf = calcDensity(ebsd.orientations);

<span class="comment">% plot the odf in sigma sections</span>
plotSection(odf,<span class="string">'sigma'</span>,<span class="string">'contour'</span>)

<span class="comment">% and on top of it the crystal shapes</span>
plot(grains(isBig).meanOrientation,0.002*cSGrains,<span class="string">'add2all'</span>)
</pre><img vspace="50" hspace="5" src="CrystalShapes_06.png" alt=""> <h2 id="9">Twinning relationships</h2><p>We may also you crystal shapes to illustrate twinning relation ships</p><pre class="codeinput"><span class="comment">% define some twinning misorientation</span>
mori = orientation.byAxisAngle(Miller({1 0-1 0},ebsd.CS),34.9*degree)

<span class="comment">% plot the crystal in ideal orientation</span>
close <span class="string">all</span>
plot(cS,<span class="string">'FaceAlpha'</span>,0.5)

<span class="comment">% and on top of it in twinning orientation</span>
hold <span class="string">on</span>
plot(mori * cS *0.9,<span class="string">'FaceColor'</span>,<span class="string">'orange'</span>)
hold <span class="string">off</span>
view(45,20)
</pre><pre class="codeoutput"> 
mori = misorientation (Titanium (Alpha) &#8594; Titanium (Alpha))
 
  Bunge Euler angles in degree
  phi1  Phi phi2
   330 34.9   30
 
</pre><img vspace="50" hspace="5" src="CrystalShapes_07.png" alt=""> <h2 id="10">Defining complicated crystal shapes</h2><p>For symmetries other then hexagonal or cubic one would like to have more complicated crystal shape representing the true appearance. To this end one has to include more faces into the representation and carefuly adjust their distance to the origin.</p><p>Lets consider a quartz crystal.</p><pre class="codeinput">cs = loadCIF(<span class="string">'quartz'</span>)
</pre><pre class="codeoutput"> 
cs = crystalSymmetry
 
  mineral        : Quartz            
  symmetry       : 321               
  elements       : 6                 
  a, b, c        : 4.9, 4.9, 5.4     
  reference frame: X||a*, Y||b, Z||c*
 
</pre><p>Its shape is mainly bounded by the following faces</p><pre class="codeinput">m = Miller({1,0,-1,0},cs);  <span class="comment">% hexagonal prism</span>
r = Miller({1,0,-1,1},cs);  <span class="comment">% positive rhomboedron, usally bigger then z</span>
z = Miller({0,1,-1,1},cs);  <span class="comment">% negative rhomboedron</span>
s1 = Miller({2,-1,-1,1},cs);<span class="comment">% left tridiagonal bipyramid</span>
s2 = Miller({1,1,-2,1},cs); <span class="comment">% right tridiagonal bipyramid</span>
x1 = Miller({6,-1,-5,1},cs);<span class="comment">% left positive Trapezohedron</span>
x2 = Miller({5,1,-6,1},cs); <span class="comment">% right positive Trapezohedron</span>
</pre><p>If we take only the first three faces we end up with</p><pre class="codeinput">N = [m,r,z];
cS = crystalShape(N)

plot(cS)
</pre><pre class="codeoutput"> 
cS = crystalShape
 mineral: Quartz (321, X||a*, Y||b, Z||c*)
 vertices: 8
 faces: 18
</pre><img vspace="50" hspace="5" src="CrystalShapes_08.png" alt=""> <p>i.e. we see only  the possitive and negative rhomboedrons, but the hexagonal prism are to far away from the origin to cut the shape. We may decrease the distance, by multiplying the coresponding normal with a factor larger then 1.</p><pre class="codeinput">N = [2*m,r,z];

cS = crystalShape(N);
plot(cS)
</pre><img vspace="50" hspace="5" src="CrystalShapes_09.png" alt=""> <p>Next in a typical Quartz crystal the negativ rhomboedron is a bit smaller then the positiv rhomboedron. Lets correct for this.</p><pre class="codeinput"><span class="comment">% collect the face normal with the right scalling</span>
N = [2*m,r,0.9*z];

cS = crystalShape(N);
plot(cS)
</pre><img vspace="50" hspace="5" src="CrystalShapes_10.png" alt=""> <p>Finaly, we add the tridiagonal bipyramid and the positive Trapezohedron</p><pre class="codeinput"><span class="comment">% collect the face normal with the right scalling</span>
N = [2*m,r,0.9*z,0.7*s1,0.3*x1];

cS = crystalShape(N);
plot(cS)
</pre><img vspace="50" hspace="5" src="CrystalShapes_11.png" alt=""> <h2 id="17">Marking crystal faces</h2><p>We may colorize the faces according to their lattice planes using the command</p><pre class="codeinput">plot(cS,<span class="string">'colored'</span>)
</pre><img vspace="50" hspace="5" src="CrystalShapes_12.png" alt=""> <p>or even label the faces directly</p><pre class="codeinput">plot(cS)
N = unique(cS.N.symmetrise,<span class="string">'noSymmetry'</span>,<span class="string">'stable'</span>);
fC = cS.faceCenter;

<span class="keyword">for</span> i = 1:length(N)
  text3(fC(i),char(round(N(i)),<span class="string">'latex'</span>),<span class="string">'scaling'</span>,1.1,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>)
<span class="keyword">end</span>
</pre><img vspace="50" hspace="5" src="CrystalShapes_13.png" alt=""> <h2 id="19">Defining complicated crystals more simple</h2><p>We see that defining a complicated crystal shape is a tedious work. To this end MTEX allows to model the shape with a habitus and a extension parameter. This approach has been developed by J. Enderlein in <a href="https://library.wolfram.com/infocenter/Articles/3279">A package for displaying crystal morphology. Mathematica Journal, 7(1), 1997</a>. The two parameters are used to model the distance of a face from the origin. Setting all parameters to one we obtain</p><pre class="codeinput"><span class="comment">% take the face normals unscaled</span>
N = [m,r,z,s2,x2];

habitus = 1;
extension = [1 1 1];
cS = crystalShape(N,habitus,extension);
plot(cS,<span class="string">'colored'</span>)
</pre><img vspace="50" hspace="5" src="CrystalShapes_14.png" alt=""> <p>The scale parameter models the inverse extension of the crystal in each dimension. In order to make the crystal a bit longer and the negative rhomboedrons smaller we could do</p><pre class="codeinput">extension = [0.9 1.1 1];
cS = crystalShape(N,habitus,extension);
plot(cS,<span class="string">'colored'</span>)
</pre><img vspace="50" hspace="5" src="CrystalShapes_15.png" alt=""> <p>Next the habitus parameter describes how close faces with mixed hkl are to the origin. If we increase the habitus parameter the trapezohedron and the bipyramid become more and more dominant</p><pre class="codeinput">habitus = 1.1;
cS = crystalShape(N,habitus,extension);
plot(cS,<span class="string">'colored'</span>), snapnow

habitus = 1.2;
cS = crystalShape(N,habitus,extension);
plot(cS,<span class="string">'colored'</span>), snapnow

habitus = 1.3;
cS = crystalShape(N,habitus,extension);
plot(cS,<span class="string">'colored'</span>)
</pre><img vspace="50" hspace="5" src="CrystalShapes_16.png" alt=""> <img vspace="50" hspace="5" src="CrystalShapes_17.png" alt=""> <img vspace="50" hspace="5" src="CrystalShapes_18.png" alt=""> <h2 id="22">Select faces</h2><p>A specific face of the crystal shape may be selected by its normal vector</p><pre class="codeinput">plot(cS)
hold <span class="string">on</span>
plot(cS(Miller(0,-1,1,0,cs)),<span class="string">'FaceColor'</span>,<span class="string">'DarkRed'</span>)
hold <span class="string">off</span>
</pre><img vspace="50" hspace="5" src="CrystalShapes_19.png" alt=""> <h2 id="23">Gallery of hardcoded crystal shapes</h2><pre class="codeinput">plot(crystalShape.olivine,<span class="string">'colored'</span>)
</pre><img vspace="50" hspace="5" src="CrystalShapes_20.png" alt=""> <pre class="codeinput">plot(crystalShape.garnet,<span class="string">'colored'</span>)
</pre><img vspace="50" hspace="5" src="CrystalShapes_21.png" alt=""> <pre class="codeinput">plot(crystalShape.topaz,<span class="string">'colored'</span>)
</pre><img vspace="50" hspace="5" src="CrystalShapes_22.png" alt=""> <pre class="codeinput">plot(crystalShape.plagioclase,<span class="string">'colored'</span>)
</pre><img vspace="50" hspace="5" src="CrystalShapes_23.png" alt=""> <p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2023a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Crystal Shapes
%
%%
% Crystal Shapes are used to visualize crystal orientations, twinning or
% lattice planes.
%
%% Simple crystal shapes
%
% In the case of cubic or hexagonal materials the corresponding crystal are
% often represented as cubes or hexagons, where the faces correspond to the
% lattice planes {100} in the cubic case and {1,0,-1,0},{0,0,0,1} in the
% hexagonal case. Such simple crystal shapes may be created in MTEX with
% the commands

% import some hexagonal data
mtexdata titanium;

% define a simple hexagonal crystal shape
cS = crystalShape.hex(ebsd.CS)

% and plot it
close all
plot(cS)

%% 
% Internally, a crystal shape is represented as a list of faces which are
% bounded by a list of vertices

cS.V


%% Calculating with crystal shapes
% Crystal shapes are defined in crystal coordinates. Thus applying an
% orientation rotates them into specimen coordinates. This functionality
% can be used to visualize crystal orientations in EBSD maps

% plot an EBSD map
clf % clear current figure
plot(ebsd,ebsd.orientations)

hold on
scaling = 100; % scale the crystal shape to have a nice size

% plot at position (500,500) the orientatation of the corresponding crystal
plot(500,500,50, ebsd(500,500).orientations * cS * scaling)
hold off


%%
% As we have seen in the previous section we can apply several operations
% on crystal shapes. These include
% 
% * |factor * cS| scales the crystal shape in size
% * |ori * cS| rotates the crystal shape in the defined orientation
% * |[xy] + cS| or |[xyz] + cS| shifts the crystal shape in the specified
% positions
%
% At this point it comes into help that MTEX supports lists of crystal
% shapes, i.e., whenever one of the operations listed above includes a
% list (e.g. a list of orientations) the multiplication will yield a list
% of crystal shapes. Lets illustrate this

% compute some grains
grains = calcGrains(ebsd);
grains = smooth(grains,5);

% and plot them
plot(grains,grains.meanOrientation)

% find the big ones
isBig = grains.grainSize>50;

% define a list of crystal shape that is oriented as the grain mean
% orientation and scaled according to the grain area
cSGrains = grains(isBig).meanOrientation * cS * 0.7 * sqrt(grains(isBig).area);

% now we can plot these crystal shapes at the grain centers
hold on
plot(grains(isBig).centroid + cSGrains)
hold off

%% Plotting crystal shapes
% The above can be accomplished a bit more directly and a bit more nice
% with

% plot a grain map
plot(grains,grains.meanOrientation)

% and on top for each large grain a crystal shape
hold on
plot(grains(isBig),0.7*cS,'FaceColor','none','linewidth',2)
hold off

%%
% In the same waywe may visualize grain orientations and grains size
% within pole figures

plotPDF(grains(isBig).meanOrientation,Miller({1,0,-1,0},{0,0,0,1},ebsd.CS),'contour')
plot(grains(isBig).meanOrientation,0.002*cSGrains,'add2all')

%%
% or even within ODF sections

% compute the odf 
odf = calcDensity(ebsd.orientations);

% plot the odf in sigma sections
plotSection(odf,'sigma','contour')

% and on top of it the crystal shapes
plot(grains(isBig).meanOrientation,0.002*cSGrains,'add2all')

%% Twinning relationships
% We may also you crystal shapes to illustrate twinning relation ships

% define some twinning misorientation
mori = orientation.byAxisAngle(Miller({1 0-1 0},ebsd.CS),34.9*degree)

% plot the crystal in ideal orientation
close all
plot(cS,'FaceAlpha',0.5)

% and on top of it in twinning orientation
hold on
plot(mori * cS *0.9,'FaceColor','orange')
hold off
view(45,20)

%% Defining complicated crystal shapes
%
% For symmetries other then hexagonal or cubic one would like to have
% more complicated crystal shape representing the true appearance. To this
% end one has to include more faces into the representation and carefuly
% adjust their distance to the origin.
%
%% 
% Lets consider a quartz crystal. 

cs = loadCIF('quartz')

%%
% Its shape is mainly bounded by the following faces

m = Miller({1,0,-1,0},cs);  % hexagonal prism
r = Miller({1,0,-1,1},cs);  % positive rhomboedron, usally bigger then z
z = Miller({0,1,-1,1},cs);  % negative rhomboedron
s1 = Miller({2,-1,-1,1},cs);% left tridiagonal bipyramid
s2 = Miller({1,1,-2,1},cs); % right tridiagonal bipyramid
x1 = Miller({6,-1,-5,1},cs);% left positive Trapezohedron
x2 = Miller({5,1,-6,1},cs); % right positive Trapezohedron

%%
% If we take only the first three faces we end up with

N = [m,r,z];
cS = crystalShape(N)

plot(cS)

%%
% i.e. we see only  the possitive and negative rhomboedrons, but the
% hexagonal prism are to far away from the origin to cut the shape. We may
% decrease the distance, by multiplying the coresponding normal with a
% factor larger then 1.

N = [2*m,r,z];

cS = crystalShape(N);
plot(cS)

%%
% Next in a typical Quartz crystal the negativ rhomboedron is a bit smaller
% then the positiv rhomboedron. Lets correct for this.

% collect the face normal with the right scalling
N = [2*m,r,0.9*z];

cS = crystalShape(N);
plot(cS)

%%
% Finaly, we add the tridiagonal bipyramid and the positive Trapezohedron

% collect the face normal with the right scalling
N = [2*m,r,0.9*z,0.7*s1,0.3*x1];

cS = crystalShape(N);
plot(cS)

%% Marking crystal faces
% We may colorize the faces according to their lattice planes using the
% command

plot(cS,'colored')

%%
% or even label the faces directly

plot(cS)
N = unique(cS.N.symmetrise,'noSymmetry','stable');
fC = cS.faceCenter;

for i = 1:length(N)
  text3(fC(i),char(round(N(i)),'latex'),'scaling',1.1,'interpreter','latex')
end



%% Defining complicated crystals more simple
% We see that defining a complicated crystal shape is a tedious work. To
% this end MTEX allows to model the shape with a habitus and a extension
% parameter. This approach has been developed by J. Enderlein in
% <https://library.wolfram.com/infocenter/Articles/3279 A package for
% displaying crystal morphology. Mathematica Journal, 7(1), 1997>. The two
% parameters are used to model the distance of a face from the origin.
% Setting all parameters to one we obtain

% take the face normals unscaled
N = [m,r,z,s2,x2];

habitus = 1;
extension = [1 1 1];
cS = crystalShape(N,habitus,extension);
plot(cS,'colored')


%%
% The scale parameter models the inverse extension of the crystal in each
% dimension. In order to make the crystal a bit longer and the negative
% rhomboedrons smaller we could do

extension = [0.9 1.1 1];
cS = crystalShape(N,habitus,extension);
plot(cS,'colored')

%%
% Next the habitus parameter describes how close faces with mixed hkl are
% to the origin. If we increase the habitus parameter the trapezohedron and
% the bipyramid become more and more dominant

habitus = 1.1;
cS = crystalShape(N,habitus,extension);
plot(cS,'colored'), snapnow

habitus = 1.2;
cS = crystalShape(N,habitus,extension);
plot(cS,'colored'), snapnow

habitus = 1.3;
cS = crystalShape(N,habitus,extension);
plot(cS,'colored')

%% Select faces
% A specific face of the crystal shape may be selected by its normal vector

plot(cS)
hold on
plot(cS(Miller(0,-1,1,0,cs)),'FaceColor','DarkRed') 
hold off

%% Gallery of hardcoded crystal shapes

plot(crystalShape.olivine,'colored')

%%

plot(crystalShape.garnet,'colored')

%%

plot(crystalShape.topaz,'colored')

%%

plot(crystalShape.plagioclase,'colored')

##### SOURCE END #####
--></body></html>