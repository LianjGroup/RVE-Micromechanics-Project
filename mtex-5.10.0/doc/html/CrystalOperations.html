
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Operations Crystal Directions</title><meta name="generator" content="MATLAB 9.14"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2023-05-21"><meta name="DC.source" content="script_CrystalOperations.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Operations Crystal Directions</h1><!--introduction--><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#3">Zone Axes</a></li><li><a href="#6">Symmetrically Equivalent Crystal Directions</a></li><li><a href="#11">Angles</a></li><li><a href="#15">Calculations</a></li><li><a href="#18">Conversions</a></li></ul></div><p>In this section we discuss basic operations with crystal directions. Therefore, lets start by importing the trigonal Quartz crystal symmetry</p><pre class="codeinput">cs = loadCIF(<span class="string">'quartz'</span>)
</pre><pre class="codeoutput"> 
cs = crystalSymmetry
 
  mineral        : Quartz            
  symmetry       : 321               
  elements       : 6                 
  a, b, c        : 4.9, 4.9, 5.4     
  reference frame: X||a*, Y||b, Z||c*
 
</pre><p>and consider two hexgonal prism normal</p><pre class="codeinput">m1 = Miller(1,-1,0,0,cs)
m2 = Miller(1,0,-1,0,cs)

plot(m1,<span class="string">'upper'</span>,<span class="string">'labeled'</span>,<span class="string">'backgroundColor'</span>,<span class="string">'w'</span>)
hold <span class="string">on</span>
plot(m2,<span class="string">'labeled'</span>,<span class="string">'backgroundColor'</span>,<span class="string">'w'</span>)
hold <span class="string">off</span>
</pre><pre class="codeoutput"> 
m1 = Miller (Quartz)
  h  k  i  l
  1 -1  0  0
 
m2 = Miller (Quartz)
  h  k  i  l
  1  0 -1  0
</pre><img vspace="50" hspace="5" src="CrystalOperations_01.png" alt=""> <h2 id="3">Zone Axes</h2><p>Both prism planes intersects in a common zone axis which is orthogonal to both plane normals can is computed by</p><pre class="codeinput">d = round(cross(m1,m2))
</pre><pre class="codeoutput"> 
d = Miller (Quartz)
  U V T W
  0 0 0 1
</pre><p>Note that MTEX automatically switches from reciprocal to direct coordinates for displaying the zone axis.</p><p>The other way round two, not paralllel, zone axes</p><pre class="codeinput">d1 = Miller(0,0,0,1,cs,<span class="string">'UVTW'</span>);
d2 = Miller(1,-2,1,3,cs,<span class="string">'UVTW'</span>);
</pre><p>span a lattice plane with normal vector</p><pre class="codeinput">round(cross(d1,d2))
</pre><pre class="codeoutput"> 
ans = Miller (Quartz)
  h  k  i  l
  1  0 -1  0
</pre><h2 id="6">Symmetrically Equivalent Crystal Directions</h2><p>Since crystal lattices are symmetric lattice directions can be grouped into classes of symmetrically equivalent directions. Those groups can be derived by permuting the Miller indeces (uvw). The class of all directions symmetrically equivalent to (uvw) is commonly denoted by <a href="uvw">uvw</a>, while the class of all lattice planes symmetrically equivalent to the plane (hkl) is denoted by {hkl}. Given a lattice direction or a lattice plane all symmetrically equivalent directions and planes are computed by the command <a href="Miller.symmetrise.html">symmetrise</a></p><pre class="codeinput">symmetrise(d2)
</pre><pre class="codeoutput"> 
ans = Miller (Quartz)
 size: 6 x 1
   U  V  T  W
   1 -2  1  3
   1  1 -2 -3
   1  1 -2  3
   1 -2  1 -3
  -2  1  1  3
  -2  1  1 -3
</pre><p>As always the keyword <a href="VectorsAxes.html">antipodal</a> adds antipodal symmetry to this computation</p><pre class="codeinput">symmetrise(d2,<span class="string">'antipodal'</span>)
</pre><pre class="codeoutput"> 
ans = Miller (Quartz)
 size: 12 x 1
   U  V  T  W
   1 -2  1  3
  -1  2 -1 -3
   1  1 -2 -3
  -1 -1  2  3
   1  1 -2  3
  -1 -1  2 -3
   1 -2  1 -3
  -1  2 -1  3
  -2  1  1  3
   2 -1 -1 -3
  -2  1  1 -3
   2 -1 -1  3
</pre><p>Using the options <b>symmetrised</b> and <b>labeled</b> all symmetrically equivalent crystal directions are plotted together with their Miller indices. Lets apply this to a list of lattice planes</p><pre class="codeinput">h = Miller({1,0,-1,0},{1,1,-2,0},{1,0,-1,1},{1,1,-2,1},{0,0,0,1},cs);

<span class="keyword">for</span> i = 1:length(h)
  plot(h(i),<span class="string">'symmetrised'</span>,<span class="string">'labeled'</span>,<span class="string">'backgroundColor'</span>,<span class="string">'w'</span>,<span class="string">'grid'</span>,<span class="string">'upper'</span>,<span class="string">'doNotDraw'</span>)
  hold <span class="string">all</span>
<span class="keyword">end</span>
hold <span class="string">off</span>
drawNow(gcm,<span class="string">'figSize'</span>,<span class="string">'normal'</span>)
</pre><img vspace="50" hspace="5" src="CrystalOperations_02.png" alt=""> <p>The command &lt;vector3d.eq.html eq or == &gt; can be used to check whether two crystal directions are symmetrically equivalent. Compare</p><pre class="codeinput">Miller(1,1,-2,0,cs) == Miller(-1,-1,2,0,cs)
</pre><pre class="codeoutput">ans =
  logical
   0
</pre><p>and</p><pre class="codeinput">eq(Miller(1,1,-2,0,cs),Miller(-1,-1,2,0,cs),<span class="string">'antipodal'</span>)
</pre><pre class="codeoutput">ans =
  logical
   1
</pre><h2 id="11">Angles</h2><p>The angle between two crystal directions m1 and m2 is defined as the smallest angle between m1 and all symmetrically equivalent directions to m2. This angle is in radians and it is calculated by the function <a href="vector3d.angle.html">angle</a></p><pre class="codeinput">angle(Miller(1,1,-2,0,cs),Miller(-1,-1,2,0,cs)) / degree
</pre><pre class="codeoutput">ans =
   60.0000
</pre><p>As always the keyword <a href="VectorsAxes.html">antipodal</a> adds antipodal symmetry to this computation</p><pre class="codeinput">angle(Miller(1,1,-2,0,cs),Miller(-1,-1,2,0,cs),<span class="string">'antipodal'</span>) / degree
</pre><pre class="codeoutput">ans =
     0
</pre><p>In order to ignore the crystal symmetry, i.e., to compute the actual angle between two directions use the option <b>noSymmetry</b></p><pre class="codeinput">angle(Miller(1,1,-2,0,cs),Miller(-1,-1,2,0,cs),<span class="string">'noSymmetry'</span>) / degree
</pre><pre class="codeoutput">ans =
   180
</pre><p>This option is available for many other functions involving crystal directions and crystal orientations.</p><h2 id="15">Calculations</h2><p>Essentially all the operations defined for general directions, i.e. for variables of type <a href="vector3d.vector3d.html">vector3d</a> are also available for Miller indices. In addition Miller indices interact with crystal orientations. Consider the crystal orientation</p><pre class="codeinput">ori = orientation.byEuler(10*degree,20*degree,30*degree,cs)
</pre><pre class="codeoutput"> 
ori = orientation (Quartz &#8594; xyz)
 
  Bunge Euler angles in degree
  phi1  Phi phi2
    10   20   30
 
</pre><p>Then one can apply it to a crystal direction to find its coordinates with respect to the specimen coordinate system</p><pre class="codeinput">ori * m1
</pre><pre class="codeoutput"> 
ans = vector3d
</pre><p>By applying a <a href="crystalSymmetry.crystalSymmetry.html">crystal symmetry</a> one obtains the coordinates with respect to the specimen coordinate system of all crystallographically equivalent specimen directions.</p><pre class="codeinput">p = ori * symmetrise(m1);
plot(p,<span class="string">'grid'</span>)

<span class="comment">%</span>
<span class="comment">% The above plot is essentialy the pole figure representation of the</span>
<span class="comment">% orientation *ori*.</span>
<span class="comment">%</span>
</pre><img vspace="50" hspace="5" src="CrystalOperations_03.png" alt=""> <h2 id="18">Conversions</h2><p>Converting a crystal direction which is represented by its coordinates with respect to the crystal coordinate system a, b, c into a representation with respect to the associated Euclidean coordinate system is done by the command <a href="Miller.vector3d.html">vectord3d</a>.</p><pre class="codeinput">vector3d(m1)
</pre><pre class="codeoutput"> 
ans = vector3d
</pre><p>Conversion into spherical coordinates requires the function <a href="vector3d.polar.html">polar</a></p><pre class="codeinput">[theta,rho] = polar(m1)
</pre><pre class="codeoutput">theta =
    1.5708
rho =
    5.2360
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2023a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Operations Crystal Directions
%
%%
% In this section we discuss basic operations with crystal directions.
% Therefore, lets start by importing the trigonal Quartz crystal symmetry

cs = loadCIF('quartz')

%%
% and consider two hexgonal prism normal

m1 = Miller(1,-1,0,0,cs)
m2 = Miller(1,0,-1,0,cs)

plot(m1,'upper','labeled','backgroundColor','w')
hold on
plot(m2,'labeled','backgroundColor','w')
hold off

%% Zone Axes
%
% Both prism planes intersects in a common zone axis which is orthogonal to
% both plane normals can is computed by

d = round(cross(m1,m2))

%%
% Note that MTEX automatically switches from reciprocal to direct
% coordinates for displaying the zone axis. 
%
% The other way round two, not paralllel, zone axes

d1 = Miller(0,0,0,1,cs,'UVTW');
d2 = Miller(1,-2,1,3,cs,'UVTW');

%%
% span a lattice plane with normal vector

round(cross(d1,d2))

%% Symmetrically Equivalent Crystal Directions
%
% Since crystal lattices are symmetric lattice directions can be grouped
% into classes of symmetrically equivalent directions. Those groups can be
% derived by permuting the Miller indeces (uvw). The class of all
% directions symmetrically equivalent to (uvw) is commonly denoted by
% <uvw>, while the class of all lattice planes symmetrically equivalent to
% the plane (hkl) is denoted by {hkl}. Given a lattice direction or a
% lattice plane all symmetrically equivalent directions and planes are
% computed by the command <Miller.symmetrise.html symmetrise>
% 

symmetrise(d2)

%%
% As always the keyword <VectorsAxes.html antipodal> adds antipodal
% symmetry to this computation

symmetrise(d2,'antipodal')

%%
% Using the options *symmetrised* and *labeled* all symmetrically
% equivalent crystal directions are plotted together with their Miller
% indices. Lets apply this to a list of lattice planes

h = Miller({1,0,-1,0},{1,1,-2,0},{1,0,-1,1},{1,1,-2,1},{0,0,0,1},cs);

for i = 1:length(h)
  plot(h(i),'symmetrised','labeled','backgroundColor','w','grid','upper','doNotDraw')
  hold all
end
hold off
drawNow(gcm,'figSize','normal')

%%
% 
% The command <vector3d.eq.html eq or == > can be used to check whether
% two crystal directions are symmetrically equivalent. Compare

Miller(1,1,-2,0,cs) == Miller(-1,-1,2,0,cs)

%%
% and

eq(Miller(1,1,-2,0,cs),Miller(-1,-1,2,0,cs),'antipodal')

%% Angles
%
% The angle between two crystal directions m1 and m2 is defined as the
% smallest angle between m1 and all symmetrically equivalent directions to
% m2. This angle is in radians and it is calculated by the function
% <vector3d.angle.html angle>

angle(Miller(1,1,-2,0,cs),Miller(-1,-1,2,0,cs)) / degree

%%
% As always the keyword <VectorsAxes.html antipodal> adds antipodal
% symmetry to this computation

angle(Miller(1,1,-2,0,cs),Miller(-1,-1,2,0,cs),'antipodal') / degree

%%
% In order to ignore the crystal symmetry, i.e., to compute the actual
% angle between two directions use the option *noSymmetry*

angle(Miller(1,1,-2,0,cs),Miller(-1,-1,2,0,cs),'noSymmetry') / degree

%%
% This option is available for many other functions involving crystal
% directions and crystal orientations.
%
%% Calculations
%
% Essentially all the operations defined for general directions, i.e. for
% variables of type <vector3d.vector3d.html vector3d> are also available for
% Miller indices. In addition Miller indices interact with crystal
% orientations. Consider the crystal orientation

ori = orientation.byEuler(10*degree,20*degree,30*degree,cs)

%%
% Then one can apply it to a crystal direction to find its coordinates with
% respect to the specimen coordinate system

ori * m1

%%
% By applying a <crystalSymmetry.crystalSymmetry.html crystal symmetry> one
% obtains the coordinates with respect to the specimen coordinate system of
% all crystallographically equivalent specimen directions.

p = ori * symmetrise(m1);
plot(p,'grid')

% 
% The above plot is essentialy the pole figure representation of the
% orientation *ori*.
%
%% Conversions
%
% Converting a crystal direction which is represented by its coordinates
% with respect to the crystal coordinate system a, b, c into a
% representation with respect to the associated Euclidean coordinate system
% is done by the command <Miller.vector3d.html vectord3d>.

vector3d(m1)

%%
% Conversion into spherical coordinates requires the function <vector3d.polar.html
% polar>

[theta,rho] = polar(m1)
##### SOURCE END #####
--></body></html>