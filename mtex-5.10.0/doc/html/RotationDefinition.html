
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Defining Rotations</title><meta name="generator" content="MATLAB 9.14"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2023-05-21"><meta name="DC.source" content="script_RotationDefinition.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Defining Rotations</h1><!--introduction--><p>MTEX offers the following functions to define rotations</p><p>
   <table class="usertable">
      <tr>
         <td>
               <p>
                  <a href="rotation.byEuler.html">
                     <tt>rotation.byEuler</tt>
                  </a>
               </p>
         </td>
         <td>
               <p>
                  <a href="rotation.byAxisAngle.html">
                     <tt>rotation.byAxisAngle</tt>
                  </a>
               </p>
         </td>
         <td>
               <p>
                  <a href="rotation.byMatrix.html">
                     <tt>rotation.byMatrix</tt>
                  </a>
               </p>
         </td>
      </tr>
      <tr>
         <td>
               <p>
                  <a href="rotation.byRodrigues.html">
                     <tt>rotation.byRodrigues</tt>
                  </a>
               </p>
         </td>
         <td>
               <p>
                  <a href="rotation.byHomochoric.html">
                     <tt>rotation.byHomochoric</tt>
                  </a>
               </p>
         </td>
         <td>
               <p>
                  <a href="rotation.byQuaternion.html">
                     <tt>rotation(quat)</tt>
                  </a>
               </p>
         </td>
      </tr>
      <tr>
         <td>
               <p>
                  <a href="rotation.id.html">
                     <tt>rotation.id</tt>
                  </a>
               </p>
         </td>
         <td>
               <p>
                  <a href="rotation.map.html">
                     <tt>rotation.map</tt>
                  </a>
               </p>
         </td>
         <td>
               <p>
                  <a href="rotation.fit.html">
                     <tt>rotation.fit</tt>
                  </a>
               </p>
         </td>
      </tr>
      <tr>
         <td>
               <p>
                  <a href="rotation.rand.html">
                     <tt>rotation.rand</tt>
                  </a>
               </p>
         </td>
         <td>
               <p>
                  <a href="SO3Fun.discreteSample.html">
                     <tt>odf.discreteSample</tt>
                  </a>
               </p>
         </td>
         <td>
               <p>
                  <a href="rotation.nan.html">
                     <tt>rotation.nan</tt>
                  </a>
               </p>
         </td>
      </tr>
      <tr>
         <td>
               <p>
                  <a href="rotation.load.html">
                     <tt>rotation.load</tt>
                  </a>
               </p>
         </td>
         <td>
               <p>
                  <a href="rotation.inversion.html">
                     <tt>rotation.inversion</tt>
                  </a>
               </p>
         </td>
         <td>
               <p>
                  <a href="rotation.mirroring.html">
                     <tt>rotation.mirroring</tt>
                  </a>
               </p>
         </td>
      </tr>
   </table>
</p><p>At the end all functions return a variable of type <a href="rotation.rotation.html"><tt>rotation</tt></a> which represents a list of rotations that are internaly stored as <a href="quaternion.quaternion.html">quaternions</a>. An overview of different rotation representations by three dimensional vectors and their properties can be found in the section <a href="RotationRepresentations.html">Representations</a>.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Euler Angles</a></li><li><a href="#5">Axis angle parametrisation and Rodrigues Frank vector</a></li><li><a href="#10">Rotation Matrix</a></li><li><a href="#12">Four vectors defining a rotation</a></li><li><a href="#15">Radom Rotations</a></li><li><a href="#16">Logarithm, Exponential Mapping, Spin Tensor</a></li><li><a href="#18">Quaternions</a></li></ul></div><h2 id="1">Euler Angles</h2><p>One of the most common ways to describe a rotation is as three subsequent rotations about fixed axes, e.g., first around the z axis, second around the x axis and third again around the z. The corresponding rotational angles are commonly called Euler angles. Beside the most common <tt>ZXZ</tt> covention other choices of the axes are sometimes used. Sorted by popularity in the texture analysis community these are</p><div><ul><li>Bunge (phi1,Phi,phi2)       - ZXZ</li><li>Matthies (alpha,beta,gamma) - ZYZ</li><li>Roe (Psi,Theta,Phi)</li><li>Kocks (Psi,Theta,phi)</li><li>Canova (omega,Theta,phi)</li></ul></div><p>The default Euler angle convention in MTEX are the Bunge Euler angles, with axes Z, X, and Z. The following command defines a rotation by its three Bunge Euler angles</p><pre class="codeinput">rot = rotation.byEuler(30*degree,50*degree,10*degree)
</pre><pre class="codeoutput"> 
rot = rotation
 
  Bunge Euler angles in degree
  phi1  Phi phi2
    30   50   10
 
</pre><p>Note that the angles needs to be multiplied with <b>degree</b> since all commands in MTEX expect the input in radiant. Furthermore, the order of the first and the third Euler angle are interchanged in comparison to standard notation for reasons explained <a href="MTEXvsBungeConvention.html">here</a>.</p><p>In order to define a rotation by a Euler angle convention different to the default Euler angle convention you to specify the convention as an additional parameter, e.g.</p><pre class="codeinput">rot = rotation.byEuler(30*degree,50*degree,10*degree,<span class="string">'Roe'</span>)
</pre><pre class="codeoutput"> 
rot = rotation
 
  Bunge Euler angles in degree
  phi1  Phi phi2
   120   50  280
 
</pre><p>This does not change the way MTEX displays the rotation on the screen. The default Euler angle convention for displaying a rotation can be changed by the command <a href="setMTEXpref.html">setMTEXpref</a>, for a permanent change the <a href="matlab:edit('mtex_settings.m')">mtex_settings</a> should be edited. Compare</p><pre class="codeinput">setMTEXpref(<span class="string">'EulerAngleConvention'</span>,<span class="string">'Roe'</span>)
rot
</pre><pre class="codeoutput"> 
rot = rotation
 
  Roe Euler angles in degree
  Psi Theta   Phi
   30    50    10
 
</pre><pre class="codeinput">setMTEXpref(<span class="string">'EulerAngleConvention'</span>,<span class="string">'Bunge'</span>)
rot
</pre><pre class="codeoutput"> 
rot = rotation
 
  Bunge Euler angles in degree
  phi1  Phi phi2
   120   50  280
 
</pre><h2 id="5">Axis angle parametrisation and Rodrigues Frank vector</h2><p>A very simple possibility to specify a rotation is to specify the rotation axis and the rotation angle.</p><pre class="codeinput">rot = rotation.byAxisAngle(xvector,30*degree)
</pre><pre class="codeoutput"> 
rot = rotation
 
  Bunge Euler angles in degree
  phi1  Phi phi2
     0   30    0
 
</pre><p>Conversely, we can extract the rotational axis and the rotation angle of a rotation by</p><pre class="codeinput">rot.axis
rot.angle ./degree
</pre><pre class="codeoutput"> 
ans = vector3d
ans =
   30.0000
</pre><p>Closely related to the axis angle parameterisation of a rotation is the Rodriguess Frank vector.</p><pre class="codeinput">R = rot.Rodrigues
</pre><pre class="codeoutput"> 
R = vector3d
</pre><p>This is the rotational axis scaled by <img src="RotationDefinition_eq16051870594363013990.png" alt="$\tan \omega/2$">, where <img src="RotationDefinition_eq11614052705438996851.png" alt="$\omega$"> is the rotational angle.</p><pre class="codeinput">2 * atan(norm(R))./degree
</pre><pre class="codeoutput">ans =
   30.0000
</pre><p>We can also define a rotation by a Rodrigues Frank vector by</p><pre class="codeinput">rotation.byRodrigues(R)
</pre><pre class="codeoutput"> 
ans = rotation
 
  Bunge Euler angles in degree
  phi1  Phi phi2
     0   30    0
 
</pre><h2 id="10">Rotation Matrix</h2><p>Another common way to represent rotations is by 3x3 matrices. The column of such a rotation matrix coincide with the new positions of the x, y and z vector after the rotation. For a given rotation we may compute the matrix by</p><pre class="codeinput">M = rot.matrix
</pre><pre class="codeoutput">M =
    1.0000         0         0
         0    0.8660   -0.5000
         0    0.5000    0.8660
</pre><p>Conversely, we may define a rotation by its matrix with the command</p><pre class="codeinput">rot = rotation.byMatrix(M)
</pre><pre class="codeoutput"> 
rot = rotation
 
  Bunge Euler angles in degree
  phi1  Phi phi2
     0   30    0
 
</pre><h2 id="12">Four vectors defining a rotation</h2><p>Another useful method to define a rotation is by describing how in acts on two given directions. More precisely, given four vectors u1, v1, u2, v2 there is a unique rotation <tt>rot</tt> such that <tt>rot * u1 = v1</tt> and <tt>rot * u2 = v2</tt>. E.g., to find the rotation the maps the x-axis onto the y-axis and keeps the z-axis we do</p><pre class="codeinput">u1 = vector3d.X;
v1 = vector3d.Y;
u2 = vector3d.Z;
v2 = vector3d.Z;


rot = rotation.map(u1,v1,u2,v2)
</pre><pre class="codeoutput"> 
rot = rotation
 
  Bunge Euler angles in degree
  phi1  Phi phi2
    90    0    0
 
</pre><p>The above definition require that the angle between u1 and u2 is the same as between v1 and v2. The function gives an error if this condition is not meet. If only two vectors are specified, then the rotation with the smallest angle is returned that rotates the first vector onto the second one.</p><pre class="codeinput">rot = rotation.map(zvector,yvector)
</pre><pre class="codeoutput"> 
rot = rotation
 
  Bunge Euler angles in degree
  phi1  Phi phi2
   180   90  180
 
</pre><p>More generaly, one can fit a rotation <tt>rot</tt> to a list of left and right vectors <tt>l</tt> and <tt>r</tt> such that <tt>rot * l</tt> is the best approximation of <tt>r</tt>. This is done by the function <a href="rotation.fit.html"><tt>rotation.fit</tt></a></p><pre class="codeinput"><span class="comment">% take five random left vectors</span>
left = vector3d.rand(5);

<span class="comment">% rotate them by rot and perturbe them a little bit</span>
right = rot * left + 0.1 * vector3d.rand(1,5);

<span class="comment">% recover the rotation rot</span>
rotation.fit(left,right)
</pre><pre class="codeoutput"> 
ans = rotation
 
  Bunge Euler angles in degree
     phi1     Phi    phi2
  178.343 91.4203  176.24
 
</pre><h2 id="15">Radom Rotations</h2><p>MTEX offers several ways for generating random rotations. In the most</p><h2 id="16">Logarithm, Exponential Mapping, Spin Tensor</h2><p>TODO</p><pre class="codeinput">S = spinTensor(rot)

rotation(S)

vector3d(S)
</pre><pre class="codeoutput"> 
S = spinTensor (xyz)
  rank: 2 (3 x 3)
 
       0       0       0
       0       0  1.5708
       0 -1.5708       0
 
ans = rotation
 
  Bunge Euler angles in degree
  phi1  Phi phi2
   180   90  180
 
 
ans = vector3d
</pre><pre class="codeinput">v = log(rot)

rotation(exp(v))
</pre><pre class="codeoutput"> 
v = vector3d
 
ans = rotation
 
  Bunge Euler angles in degree
  phi1  Phi phi2
   180   90  180
 
</pre><h2 id="18">Quaternions</h2><p>A last possibility to define a rotation is by <a href="quaternion.quaternion.html">quaternion coordinates</a> a, b, c, d.</p><pre class="codeinput">q = quaternion(1,0,0,0)

rot = rotation(q)
</pre><pre class="codeoutput"> 
q = quaternion
  a b c d
  1 0 0 0
 
rot = rotation
 
  Bunge Euler angles in degree
  phi1  Phi phi2
     0    0    0
 
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2023a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Defining Rotations
%
% MTEX offers the following functions to define rotations
%
% 
% <html>
%    <table class="usertable">
%       <tr>
%          <td>
%                <p>
%                   <a href="rotation.byEuler.html">
%                      <tt>rotation.byEuler</tt>
%                   </a>
%                </p>
%          </td>
%          <td>
%                <p>
%                   <a href="rotation.byAxisAngle.html">
%                      <tt>rotation.byAxisAngle</tt>
%                   </a>
%                </p>
%          </td>
%          <td>
%                <p>
%                   <a href="rotation.byMatrix.html">
%                      <tt>rotation.byMatrix</tt>
%                   </a>
%                </p>
%          </td>
%       </tr>
%       <tr>
%          <td>
%                <p>
%                   <a href="rotation.byRodrigues.html">
%                      <tt>rotation.byRodrigues</tt>
%                   </a>
%                </p>
%          </td>
%          <td>
%                <p>
%                   <a href="rotation.byHomochoric.html">
%                      <tt>rotation.byHomochoric</tt>
%                   </a>
%                </p>
%          </td>
%          <td>
%                <p>
%                   <a href="rotation.byQuaternion.html">
%                      <tt>rotation(quat)</tt>
%                   </a>
%                </p>
%          </td>
%       </tr>
%       <tr>
%          <td>
%                <p>
%                   <a href="rotation.id.html">
%                      <tt>rotation.id</tt>
%                   </a>
%                </p>
%          </td>
%          <td>
%                <p>
%                   <a href="rotation.map.html">
%                      <tt>rotation.map</tt>
%                   </a>
%                </p>
%          </td>
%          <td>
%                <p>
%                   <a href="rotation.fit.html">
%                      <tt>rotation.fit</tt>
%                   </a>
%                </p>
%          </td>
%       </tr>
%       <tr>
%          <td>
%                <p>
%                   <a href="rotation.rand.html">
%                      <tt>rotation.rand</tt>
%                   </a>
%                </p>
%          </td>
%          <td>
%                <p>
%                   <a href="SO3Fun.discreteSample.html">
%                      <tt>odf.discreteSample</tt>
%                   </a>
%                </p>
%          </td>
%          <td>
%                <p>
%                   <a href="rotation.nan.html">
%                      <tt>rotation.nan</tt>
%                   </a>
%                </p>
%          </td>
%       </tr>
%       <tr>
%          <td>
%                <p>
%                   <a href="rotation.load.html">
%                      <tt>rotation.load</tt>
%                   </a>
%                </p>
%          </td>
%          <td>
%                <p>
%                   <a href="rotation.inversion.html">
%                      <tt>rotation.inversion</tt>
%                   </a>
%                </p>
%          </td>
%          <td>
%                <p>
%                   <a href="rotation.mirroring.html">
%                      <tt>rotation.mirroring</tt>
%                   </a>
%                </p>
%          </td>
%       </tr>
%    </table>
% </html>
% 
%
% At the end all functions return a variable of type
% <rotation.rotation.html |rotation|> which represents a list of rotations
% that are internaly stored as <quaternion.quaternion.html quaternions>. An
% overview of different rotation representations by three dimensional
% vectors and their properties can be found in the section
% <RotationRepresentations.html Representations>.
%
%% Euler Angles
%
% One of the most common ways to describe a rotation is as three subsequent
% rotations about fixed axes, e.g., first around the z axis, second around
% the x axis and third again around the z. The corresponding rotational
% angles are commonly called Euler angles. Beside the most common |ZXZ|
% covention other choices of the axes are sometimes used. Sorted by
% popularity in the texture analysis community these are
%
% * Bunge (phi1,Phi,phi2)       - ZXZ
% * Matthies (alpha,beta,gamma) - ZYZ
% * Roe (Psi,Theta,Phi)
% * Kocks (Psi,Theta,phi)
% * Canova (omega,Theta,phi)
%
% The default Euler angle convention in MTEX are the Bunge Euler angles,
% with axes Z, X, and Z. The following command defines a rotation by its
% three Bunge Euler angles

rot = rotation.byEuler(30*degree,50*degree,10*degree)

%%
% Note that the angles needs to be multiplied with *degree* since all
% commands in MTEX expect the input in radiant. Furthermore, the order of
% the first and the third Euler angle are interchanged in comparison to
% standard notation for reasons explained <MTEXvsBungeConvention.html
% here>.
%
% In order to define a rotation by a Euler angle convention different to
% the default Euler angle convention you to specify the convention as an
% additional parameter, e.g.

rot = rotation.byEuler(30*degree,50*degree,10*degree,'Roe')

%%
% This does not change the way MTEX displays the rotation on the screen.
% The default Euler angle convention for displaying a rotation can be
% changed by the command <setMTEXpref.html setMTEXpref>, for a permanent
% change the <matlab:edit('mtex_settings.m') mtex_settings> should be
% edited. Compare

setMTEXpref('EulerAngleConvention','Roe')
rot

%%
setMTEXpref('EulerAngleConvention','Bunge')
rot

%% Axis angle parametrisation and Rodrigues Frank vector
%
% A very simple possibility to specify a rotation is to specify the
% rotation axis and the rotation angle.

rot = rotation.byAxisAngle(xvector,30*degree)

%%
% Conversely, we can extract the rotational axis and the rotation angle of
% a rotation by

rot.axis
rot.angle ./degree

%%
% Closely related to the axis angle parameterisation of a rotation is the
% Rodriguess Frank vector. 

R = rot.Rodrigues

%%
% This is the rotational axis scaled by $\tan \omega/2$, where $\omega$ is
% the rotational angle.
2 * atan(norm(R))./degree

%%
% We can also define a rotation by a Rodrigues Frank vector by

rotation.byRodrigues(R)


%% Rotation Matrix
%
% Another common way to represent rotations is by 3x3 matrices. The column
% of such a rotation matrix coincide with the new positions of the x, y and
% z vector after the rotation. For a given rotation we may compute the
% matrix by

M = rot.matrix

%%
% Conversely, we may define a rotation by its matrix with the command

rot = rotation.byMatrix(M)


%% Four vectors defining a rotation
%
% Another useful method to define a rotation is by describing how in acts
% on two given directions. More precisely, given four vectors u1, v1, u2,
% v2 there is a unique rotation |rot| such that |rot * u1 = v1| and |rot *
% u2 = v2|. E.g., to find the rotation the maps the x-axis onto the y-axis
% and keeps the z-axis we do

u1 = vector3d.X;
v1 = vector3d.Y;
u2 = vector3d.Z;
v2 = vector3d.Z;


rot = rotation.map(u1,v1,u2,v2)

%%
% The above definition require that the angle between u1 and u2 is the same
% as between v1 and v2. The function gives an error if this condition is
% not meet. If only two vectors are specified, then the rotation with the
% smallest angle is returned that rotates the first vector onto the second
% one.

rot = rotation.map(zvector,yvector)

%%
% More generaly, one can fit a rotation |rot| to a list of left and right
% vectors |l| and |r| such that |rot * l| is the best approximation of |r|.
% This is done by the function <rotation.fit.html |rotation.fit|>

% take five random left vectors
left = vector3d.rand(5);

% rotate them by rot and perturbe them a little bit
right = rot * left + 0.1 * vector3d.rand(1,5);

% recover the rotation rot
rotation.fit(left,right)


%% Radom Rotations
%
% MTEX offers several ways for generating random rotations. In the most 




%% Logarithm, Exponential Mapping, Spin Tensor
%
% TODO

S = spinTensor(rot)

rotation(S)

vector3d(S)

%%

v = log(rot)

rotation(exp(v))

%% Quaternions
%
% A last possibility to define a rotation is by <quaternion.quaternion.html
% quaternion coordinates> a, b, c, d.

q = quaternion(1,0,0,0)

rot = rotation(q)

##### SOURCE END #####
--></body></html>